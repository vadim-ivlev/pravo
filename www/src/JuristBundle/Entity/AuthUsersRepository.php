<?php

namespace JuristBundle\Entity;

use Doctrine\ORM\EntityRepository;
use JuristBundle\Entity\Questions;

use JuristBundle\Controller\ApiController;

use JuristBundle\InterfaceCustom\createSitemapRepositoryInterface;

/**
 * QuestionRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class AuthUsersRepository extends \Doctrine\ORM\EntityRepository implements createSitemapRepositoryInterface
{
    private $oDBALConnection;

    public function __construct($em, $class)
    {
        parent::__construct($em, $class);
        $this->oDBALConnection = $this->getEntityManager()->getConnection();
    }

    /**
     * Удаляет из ssi_storage_path уже не существующие пути до ssi
     * @param $where
     */
    public function delPathSSI($where)
    {
        try {
            $sql = "
              DELETE FROM ssi_storage_path
              WHERE {$where}
            ";

            $stmt = $this->oDBALConnection->prepare($sql);

            $stmt->execute();
        } catch (\PDOException $e) {
            $e->getTrace();
        }
    }

    public function getRubricsAndTagsPathSSI($em, $juristId)
    {
        try {
            $sql = "
              SELECT aur.auth_users_id, aur.rubrics_id, r.CPU_name AS cpu_name
              FROM auth_users_rubrics AS aur
                JOIN rubrics AS r ON r.id = aur.rubrics_id
              WHERE auth_users_id = :id;
            ";

            $stmt = $this->oDBALConnection->prepare($sql);
            $stmt->bindValue('id', $juristId);

            $stmt->execute();

            $rubrics = $tags = [];

            foreach ($stmt->fetchAll( \PDO::FETCH_ASSOC) as $rubric) {
                $result = $em
                    ->getRepository('JuristBundle:Tags')
                    ->getAllRelatedRubricsTags('rubrics', $rubric['rubrics_id']);
                if (!empty($result))
                    $tags = array_merge($tags, $result);

                $result = $em
                    ->getRepository('JuristBundle:Tags')
                    ->invalidateCacheSSI('rubrics', $rubric['cpu_name']);
                if (!empty($result))
                    $rubrics = array_merge($rubrics, $result);
            }

            return array_merge($rubrics, $tags);
        } catch (\PDOException $e) {
            $e->getTrace();
        }
    }

    public function getRubricsAndTagsViaQuestionIdPathSSI($em, $questionId)
    {
        try {
            $sql = "
              SELECT rq.rubrics_id, rq.questions_id, r.CPU_name AS cpu_name
                  FROM rubrics_questions AS rq
              JOIN rubrics AS r on r.id = rq.rubrics_id
              WHERE rq.questions_id = :id;
            ";

            $stmt = $this->oDBALConnection->prepare($sql);
            $stmt->bindValue('id', $questionId);

            $stmt->execute();

            $rubrics = $tags = [];

            foreach ($stmt->fetchAll( \PDO::FETCH_ASSOC) as $rubric) {
                $result = $em
                    ->getRepository('JuristBundle:Tags')
                    ->getAllRelatedRubricsTags('rubrics', $rubric['rubrics_id']);
                if (!empty($result))
                    $tags = array_merge($tags, $result);

                $result = $em
                    ->getRepository('JuristBundle:Tags')
                    ->invalidateCacheSSI('rubrics', $rubric['cpu_name']);
                if (!empty($result))
                    $rubrics = array_merge($rubrics, $result);
            }

            return array_merge($rubrics, $tags);
        } catch (\PDOException $e) {
            $e->getTrace();
        }
    }

    public function getRubricsTagsAndJuristsViaRubricsIdPathSSI($em, $rubricsId)
    {
        try {
            $sql = "
              SELECT r.id AS rubrics_id, t.id AS tags_id, r.CPU_name AS cpu_name
              FROM tags_rubrics AS tg
                  JOIN rubrics AS r ON r.id = tg.rubrics_id
                  JOIN tags AS t ON t.id = tg.tags_id
              WHERE tg.rubrics_id = :id;
            ";

            $stmt = $this->oDBALConnection->prepare($sql);
            $stmt->bindValue('id', $rubricsId);

            $stmt->execute();

            $rubrics = $tags = $jurists = [];

            $rubricsAndTags = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            foreach ($rubricsAndTags as $rubric) {
                $result = $em
                    ->getRepository('JuristBundle:Tags')
                    ->invalidateCacheSSI('tags', $rubric['tags_id']);
                if (!empty($result))
                    $tags = array_merge($tags, $result);
            }

            if (!empty($rubricsAndTags[0]['cpu_name'])) {
                $result = $em
                    ->getRepository('JuristBundle:Tags')
                    ->invalidateCacheSSI('rubrics', $rubricsAndTags[0]['cpu_name']);
                if (!empty($result))
                    $rubrics = array_merge($rubrics, $result);
            }

            $sql = "
                SELECT au.id as au_id
                FROM auth_users_rubrics AS aur
                    JOIN auth_users AS au ON aur.auth_users_id = au.id
                WHERE aur.rubrics_id = :id;
            ";

            $stmt = $this->oDBALConnection->prepare($sql);
            $stmt->bindValue('id', $rubricsId);

            $stmt->execute();

            foreach ($stmt->fetchAll(\PDO::FETCH_ASSOC) as $jurist) {
                $result = $em
                    ->getRepository('JuristBundle:Tags')
                    ->invalidateCacheSSI('jurists', $jurist['au_id']);
                if (!empty($result)) {
                    $jurists = array_merge($jurists, $result);
                }
            }

            return array_merge($rubrics, $tags, $jurists);
        } catch (\PDOException $e) {
            $e->getTrace();
        }
    }

    public function getJuristByQuestionId($em, $questionId)
    {
        try {
            $sql = "
              SELECT q.authUsers_id FROM questions AS q where q.id = :id;
            ";

            $stmt = $this->oDBALConnection->prepare($sql);
            $stmt->bindValue('id', $questionId);

            $stmt->execute();

            return $em
                ->getRepository('JuristBundle:Tags')
                ->invalidateCacheSSI('jurists', $stmt->fetchColumn());
        } catch (\PDOException $e) {
            $e->getTrace();
        }
    }

    private function fetchAllQuery($sql, array $arrayAnswersId = [], array $doctrineParam = [])
    {
        $query = $this->oDBALConnection->executeQuery(
            $sql,
            $arrayAnswersId,
            $doctrineParam
        );

        $query->execute();
        return $query->fetchAll( \PDO::FETCH_ASSOC);
    }

    public function generateSiteMap()
    {
        $userExceptionId = ApiController::ID_USER_WITHOUT_AVATARS;
        $userActive = ApiController::VALUE_ACTIVE_USER;

        $sql = "
            SELECT id AS loc, edit_date AS date
            FROM auth_users AS au
            WHERE au.is_jurist = true AND au.disabled = {$userActive} AND au.id != {$userExceptionId};
        ";

        return $this->fetchAllQuery($sql);
    }

    public function getAllPathJurists()
    {
        $sql = "SELECT * FROM ssi_storage_path WHERE path like '%jurists%';";

        try {
            $stmt = $this->oDBALConnection->prepare($sql);
            $stmt->execute();

            return $stmt->fetchAll(\PDO::FETCH_NAMED);

        } catch (\PDOException $e) {
            $e->getTrace();
        }
    }

    public function fetchJurists(array $orderBy, array $where, $offset, $limit = \JuristBundle\Controller\JuristsController::COUNT_RECORDS_ON_PAGE_JURISTS)
    {
        $whereSQL = "";
        foreach ($where as $value) {
            $whereSQL .= " {$value['field_condition']} {$value['field_oDBAL']}";
        }

        $this->oDBALConnection->query('SET group_concat_max_len = 10048')->execute();

        $sql = "
            SELECT 
            
            au.id AS au_id, au.name AS au_name, au.second_name AS au_second_name, au.disabled AS au_disabled,
            au.graduate AS au_graduate, au.patronymic AS au_patronymic, au.total_rating AS au_total_rating,
            au.directory AS au_directory, au.filename AS au_filename,
            
            c.id AS c_id, c.name AS c_name,
            
            (SELECT COUNT(a1.id) FROM answers AS a1 WHERE a1.auth_users_id = au.id) AS a_count,
            
            (
              SELECT 
                CONCAT('[', GROUP_CONCAT('{\"r_id\":\"', r1.id, '\",\"r_name\":\"', r1.name SEPARATOR '\"}, '), '\"}]') AS `data`
              FROM rubrics AS r1
                JOIN auth_users_rubrics AS aur1 ON aur1.rubrics_id = r1.id
                JOIN auth_users AS au1 ON au1.id = aur1.auth_users_id
              WHERE au1.id = au.id 
            ) AS `rubric`
              
            FROM 
              auth_users AS au
            
              LEFT JOIN answers AS a ON a.auth_users_id = au.id
              JOIN companies AS c ON c.id = au.companies_id
              
              JOIN auth_users_rubrics AS aur ON aur.auth_users_id = au.id
              JOIN rubrics AS r1 ON r1.id = aur.rubrics_id
              
            WHERE 
              au.disabled = :disabled AND au.is_jurist = :is_jurist AND au.id != :au_id {$whereSQL}
            GROUP BY au.id
            ORDER BY " . implode(', ', $orderBy) . "
            LIMIT :limit
            OFFSET :offset
        ";

        try {
            $stmt = $this->oDBALConnection->prepare($sql);

            $stmt->bindValue('disabled', (boolean)\JuristBundle\Controller\ApiController::VALUE_ACTIVE_USER);
            $stmt->bindValue('is_jurist', true);
            $stmt->bindValue('au_id', \JuristBundle\Controller\ApiController::ID_USER_WITHOUT_AVATARS);

            if (!empty($where))
                foreach ($where as $value)
                    $stmt->bindValue($value['field_oDBAL'], $value['value']);

            //$stmt->bindValue('order_by', implode(', ', $orderBy), \PDO::PARAM_STR);

//            if ($_SERVER['REMOTE_ADDR'] === '212.69.111.131') {
//                    dump($limit . " | " . $offset);die;
//                    var_dump($sql);die;
//                }
            $stmt->bindValue('limit', $limit, \PDO::PARAM_INT);
            $stmt->bindValue('offset', $offset, \PDO::PARAM_INT);
            $stmt->execute();
            return $stmt->fetchAll(\PDO::FETCH_NAMED);

        } catch (\PDOException $e) {
            $e->getTrace();
        }
    }
}